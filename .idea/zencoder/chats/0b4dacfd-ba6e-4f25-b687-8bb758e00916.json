{
    "checksum": "35cbc9fd0fb45dda94ae111d9ac73330653d8cbbcbd9562991c8d32f68762561",
    "data": {
    "id": "0b4dacfd-ba6e-4f25-b687-8bb758e00916",
    "createdAt": 1754628361899,
    "updatedAt": 1754628361991,
    "title": "read program_idea.md and create this program fo...",
    "messages": [
        {
            "id": "070c70d5-acb5-497c-a39e-14c403536ae3",
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "read program_idea.md and create this program for real time scanning of magic and pokemon and sports cards in batches and storing the data collected for later upload to auction program."
                }
            ],
            "context": {
                "currentFile": {
                    "path": "program_idea.md",
                    "fsPath": "/Users/seanmorrissey/Desktop/Coding/CameraCapture/program_idea.md",
                    "sources": [
                        "opened_tab"
                    ],
                    "content": "import cv2\n\ndef capture_image(output_path=\"mtg_card.jpg\"):\n    cap = cv2.VideoCapture(0) # Access the default camera\n    if not cap.isOpened():\n        raise RuntimeError(\"Cannot access the webcam.\")\n    while True:\n        ret, frame = cap.read()\n        if not ret:\n            print(\"Failed to grab frame.\")\n            break\n        cv2.imshow(\"Capture Card - Press SPACE to snap, ESC to quit\", frame)\n        key = cv2.waitKey(1)\n        if key == 27:  # ESC key\n            break\n        elif key == 32:  # SPACE key\n            cv2.imwrite(output_path, frame)\n            print(f\"Saved image to {output_path}\")\n            break\n    cap.release()\n    cv2.destroyAllWindows()\n    return output_path\n\n# Usage:\n# capture_image(\"my_captured_card.jpg\")\nimport numpy as np\n\ndef extract_card_roi(image_path, save_path=\"mtg_card_aligned.jpg\"):\n    img = cv2.imread(image_path)\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    blur = cv2.GaussianBlur(gray, (5,5), 0)\n    edged = cv2.Canny(blur, 50, 150)\n    contours, _ = cv2.findContours(edged, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    # Assume the largest rectangular contour is the card\n    card_contour = max(contours, key=cv2.contourArea)\n    peri = cv2.arcLength(card_contour, True)\n    approx = cv2.approxPolyDP(card_contour, 0.02*peri, True)\n    if len(approx) != 4:\n        raise ValueError(\"Could not detect card corners.\")\n\n    # Get a bird's-eye view\n    pts = approx.reshape(4, 2)\n    # Order the points [top-left, top-right, bottom-right, bottom-left]\n    rect = order_points(pts)\n    (tl, tr, br, bl) = rect\n    widthA = np.linalg.norm(br - bl)\n    widthB = np.linalg.norm(tr - tl)\n    heightA = np.linalg.norm(tr - br)\n    heightB = np.linalg.norm(tl - bl)\n    maxWidth = max(int(widthA), int(widthB))\n    maxHeight = max(int(heightA), int(heightB))\n    dst = np.array([[0,0],[maxWidth-1,0],[maxWidth-1,maxHeight-1],[0,maxHeight-1]], dtype=\"float32\")\n    M = cv2.getPerspectiveTransform(rect, dst)\n    warp = cv2.warpPerspective(img, M, (maxWidth, maxHeight))\n    cv2.imwrite(save_path, warp)\n    return save_path\n\ndef order_points(pts):\n    # Returns points ordered as top-left, top-right, bottom-right, bottom-left\n    rect = np.zeros((4, 2), dtype=\"float32\")\n    s = pts.sum(axis=1)\n    diff = np.diff(pts, axis=1)\n    rect[0] = pts[np.argmin(s)]   # tl\n    rect[2] = pts[np.argmax(s)]   # br\n    rect[1] = pts[np.argmin(diff)] # tr\n    rect[3] = pts[np.argmax(diff)] # bl\n    return rect\ndef crop_name_box(card_img_path, save_path=\"name_box.jpg\", crop_ratio=(0.05, 0.20)):\n    img = cv2.imread(card_img_path)\n    h, w = img.shape[:2]\n    y1 = int(h * crop_ratio[0])\n    y2 = int(h * crop_ratio[1])\n    name_roi = img[y1:y2, :]  # Crop top region\n    cv2.imwrite(save_path, name_roi)\n    return save_path\n\ndef preprocess_for_ocr(name_box_path, save_path=\"preprocessed_name_box.jpg\"):\n    img = cv2.imread(name_box_path)\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    blur = cv2.medianBlur(gray, 3)\n    # Otsu’s thresholding often works well for isolated text\n    _, thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n    cv2.imwrite(save_path, thresh)\n    return save_path\nimport pytesseract\n\ndef extract_card_name(preprocessed_name_box_path):\n    # Optionally set up Tesseract path if not in system PATH\n    # pytesseract.pytesseract.tesseract_cmd = r'/usr/bin/tesseract'\n    img = cv2.imread(preprocessed_name_box_path)\n    # For single-line text, PSM 7 is effective\n    config = \"--psm 7 --oem 3\"\n    raw_text = pytesseract.image_to_string(img, config=config, lang=\"eng\")\n    # Clean up text: remove newlines, extra spaces, non-alphanumeric\n    cleaned = ''.join(char for char in raw_text if char.isalnum() or char.isspace()).strip()\n    return cleaned\nfrom thefuzz import process\n\ndef fuzzy_match_card_name(raw_name, card_name_list, threshold=80):\n    # Return best match and score if above threshold, else None\n    best_match, score = process.extractOne(raw_name, card_name_list)\n    return (best_match, score) if score > threshold else (None, 0)\nimport requests\nimport time\n\ndef get_scryfall_card_data(card_name, user_agent=\"MTGRecognizer/1.0\"):\n    url = \"https://api.scryfall.com/cards/named\"\n    params = {\"fuzzy\": card_name}\n    headers = {\n        \"User-Agent\": user_agent,\n        \"Accept\": \"application/json\",\n    }\n    response = requests.get(url, params=params, headers=headers)\n    if response.status_code == 200:\n        return response.json()\n    elif response.status_code == 404:\n        print(\"No card named '{}' found on Scryfall.\".format(card_name))\n        return None\n    elif response.status_code == 429:\n        print(\"Rate limit exceeded. Retrying after delay...\")\n        time.sleep(0.2)\n        return get_scryfall_card_data(card_name, user_agent)\n    else:\n        print(f\"Error {response.status_code}: {response.text}\")\n        return None\ndef parse_card_json(card_json):\n    # Handles single-faced and double-faced cards\n    if card_json.get('card_faces'):\n        name = \" // \".join(face['name'] for face in card_json['card_faces'])\n        image_url = card_json['card_faces'][0]['image_uris']['normal']\n    else:\n        name = card_json['name']\n        image_url = card_json['image_uris']['normal']\n\n    data = {\n        \"name\": name,\n        \"set\": card_json.get(\"set\"),\n        \"set_name\": card_json.get(\"set_name\"),\n        \"oracle_text\": card_json.get(\"oracle_text\"),\n        \"type_line\": card_json.get(\"type_line\"),\n        \"mana_cost\": card_json.get(\"mana_cost\"),\n        \"rarity\": card_json.get(\"rarity\"),\n        \"color_identity\": card_json.get(\"color_identity\"),\n        \"legalities\": card_json.get(\"legalities\"),\n        \"prices\": card_json.get(\"prices\"),\n        \"image_url\": image_url,\n        \"scryfall_uri\": card_json.get(\"scryfall_uri\"),\n    }\n    return data\nimport json\n\ndef save_json(data, filename):\n    with open(filename, 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=4)\ndef save_json_with_error_handling(data, filename):\n    import errno\n    try:\n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(data, f, ensure_ascii=False, indent=4)\n    except IOError as e:\n        print(f\"File error: {e.strerror}\")\n    except Exception as e:\n        print(f\"Failed to save JSON: {str(e)}\")\ndef download_image(url, destination_path):\n    import requests\n    response = requests.get(url, stream=True)\n    if response.status_code == 200:\n        with open(destination_path, 'wb') as f:\n            for block in response.iter_content(1024):\n                if not block:\n                    break\n                f.write(block)\n        print(f\"Image saved as {destination_path}\")\n    else:\n        print(f\"Failed to download image. HTTP {response.status_code}\")\nmtgcardtool/\n│\n├── app/                   # Main application code\n│   ├── __init__.py\n│   ├── image_capture.py   # Functions to capture/process images\n│   ├── ocr.py             # Preprocessing and OCR logic\n│   ├── scryfall.py        # API interaction & parsing\n│   ├── utils.py           # Helper functions (caching, error handling)\n│   └── main.py            # CLI interface\n│\n├── tests/                 # Unit tests\n│   └── test_*.py\n├── requirements.txt\n├── README.md\n└── setup.py\n{\n    \"name\": \"Lightning Bolt\",\n    \"set\": \"m10\",\n    \"set_name\": \"Magic 2010\",\n    \"oracle_text\": \"Lightning Bolt deals 3 damage to any target.\",\n    \"type_line\": \"Instant\",\n    \"mana_cost\": \"{R}\",\n    \"rarity\": \"common\",\n    \"color_identity\": [\"R\"],\n    \"legalities\": {\n        \"standard\": \"not_legal\",\n        \"commander\": \"legal\",\n        \"modern\": \"legal\",\n        ...\n    },\n    \"prices\": {\n        \"usd\": \"2.50\",\n        \"usd_foil\": \"5.00\",\n        \"eur\": \"2.00\",\n        \"tix\": \"0.05\"\n    },\n    \"image_url\": \"https://cards.scryfall.io/normal/front/5/d/5d9b05a4-500e-4a4d-9f95-847d332b2d2c.jpg\",\n    \"scryfall_uri\": \"https://scryfall.com/card/m10/146/lightning-bolt\"\n}\ndef main_workflow():\n    # 1. Capture image (or use file)\n    path = capture_image()  # or pass as argument\n    \n    # 2. Detect card and align\n    roi_path = extract_card_roi(path)\n    \n    # 3. Crop and preprocess name box\n    name_box_path = crop_name_box(roi_path)\n    preproc_path = preprocess_for_ocr(name_box_path)\n    \n    # 4. OCR the card name\n    raw_name = extract_card_name(preproc_path)\n    \n    # 5. Fuzzy match to legal names\n    card_list = load_all_card_names()  # from Scryfall bulk file\n    best_match, score = fuzzy_match_card_name(raw_name, card_list)\n    if not best_match:\n        print(\"Failed to confidently match card name. Try again.\")\n        return\n    \n    # 6. Query Scryfall for details\n    card_json = get_scryfall_card_with_cache(best_match)\n    if not card_json:\n        print(\"Scryfall lookup failed.\")\n        return\n\n    # 7. Parse and save metadata\n    card_data = parse_card_json(card_json)\n    save_json(card_data, f\"{best_match}.json\")\n\n    # 8. Download image\n    download_image(card_data['image_url'], f\"{best_match}.jpg\")\n    print(f\"Card '{best_match}' recognized and data saved.\")\n\nif __name__ == \"__main__\":\n    main_workflow()\n\n# UI Layout and Components\n\n## Main Application Window\n\nThe application will feature a modern, user-friendly interface with the following layout:\n\n### Top Section: Dual-Panel Display\n- **Left Panel: Live Camera Feed**\n  - Displays the raw camera feed in real-time (15-30 FPS)\n  - Automatically detects and draws colored bounding boxes around card regions\n  - Highlights the currently focused card with a thicker border\n  - Shows card detection confidence level near each detected card\n  - Includes visual feedback for focus and exposure\n  - Has a prominent capture button and auto-capture toggle\n\n- **Right Panel: Card Information**\n  - **Card Header**\n    - Large, prominent card name with set symbol\n    - Mana cost displayed as colored icons\n    - Card type and subtype (e.g., \"Creature — Human Wizard\")\n  - **Card Image**\n    - High-resolution image of the recognized card\n    - Toggle between front and back faces for double-faced cards\n  - **Card Details**\n    - Oracle text and rules\n    - Power/Toughness for creatures\n    - Loyalty for planeswalkers\n    - Set name and collector number\n    - Current market prices (if available)\n    - Rarity indicator\n  - **Quick Actions**\n    - Add to collection\n    - View full details\n    - Open in Scryfall\n\n### Bottom Section: Capture Log Table\n- A scrollable table displaying previously captured cards with columns for:\n  - Timestamp\n  - Card name\n  - Set code\n  - Condition\n  - Quantity\n  - Estimated value\n  - Actions (Edit, Delete, View Details)\n- Table will support:\n  - Sorting by any column\n  - Filtering by set, color, or other attributes\n  - Bulk selection for batch operations\n\n### Controls and Status Bar\n- Capture button (large, prominent)\n- Toggle for auto-capture mode\n- Settings/Preferences\n- Status indicators (camera status, internet connection, etc.)\n- Progress indicators for long-running operations\n\n## Responsive Design\n- Layout will adapt to different window sizes\n- Video feeds will maintain aspect ratio\n- Information panels will be collapsible for smaller screens\n\n## Accessibility Features\n- Keyboard shortcuts for common actions\n- High contrast mode\n- Adjustable text sizes\n- Screen reader support\n\n## Implementation Notes\n- **GUI Framework**: PyQt5 for the user interface\n- **Image Processing**: OpenCV for video capture and image manipulation\n- **Text Recognition**: Tesseract OCR for extracting text from captured card images\n  - Pre-processing steps to improve OCR accuracy:\n    - Image deskewing and perspective correction\n    - Adaptive thresholding for better text contrast\n    - Noise reduction and edge detection\n    - Region of interest (ROI) extraction for different text elements\n  - Post-processing to clean and validate extracted text\n- **Background Processing**: QThread for non-blocking UI during OCR and API operations\n- **Custom Widgets**: Specialized components for card display and interaction\n",
                    "language": "markdown"
                },
                "codebaseEnabled": false
            },
            "createdAt": 1754628361985,
            "isInternal": false,
            "rawContent": {
                "type": "doc",
                "content": [
                    {
                        "type": "paragraph",
                        "content": [
                            {
                                "type": "text",
                                "text": "read program_idea.md and create this program for real time scanning of magic and pokemon and sports cards in batches and storing the data collected for later upload to auction program."
                            }
                        ]
                    }
                ]
            },
            "autoAppliedRules": []
        }
    ],
    "isAgent": true,
    "isCustomAgent": false,
    "isUnitTestsAgent": false,
    "isE2EAgent": false,
    "isQnaAgent": false,
    "isRepoInfoAgent": false,
    "isClaudeCode": false,
    "autoApply": true,
    "model": "default"
}
}